---
title: 'Fullstack Entertainment Application'
slug: 'fullstack-entertainment'
repoLink: 'https://github.com/JorgeAMendoza/entertainment-web-app'
demoLink: 'https://entertainment-web-app-ivory.vercel.app'
projectGif: '/project-images/ent-app/showcase.gif'
projectImage: '/project-images/ent-app/project-image.png'
tools:
  [
    'graph-ql',
    'react',
    'typescript',
    'mongodb',
    'node-js',
    'styled-components',
    'cypress',
    'react-router',
  ]
---

## Table of Contents

- [Introduction](#introduction)
- [Techstack Used](#techstack-used)
  - [Client](#frontend/client)
  - [Server](#backendserver)
  - [Docker](#docker)

## Introduction

Project requirements and design provided thanks to [FrontEndMentors](https://www.frontendmentor.io/challenges/entertainment-web-app-J-UhgAW1X).

The requirement of the project is to create an entertainment app where a user can navigate through TV shows, movies, bookmarked, or all content. The project's initial requirement is to create a user interface with static data provided, but as an extra challenge, I created a full-stack application that aimed to achieve the following:

1. **Authentication**, user's are able to create an account and can only interact with the application if they are authenticated.
2. **Database modification**, user's are able to bookmark content, remove bookmarked content, and have those changes reflect on the user-interface and in the backend.
3. **Front/backend testing**, test the entire application to have confidence in client-side and server-side deployments.

## Techstack Used

This section contains information about the technology used for both the front-end and backend. [ESlint](https://eslint.org/) is used to lint the application, with one general ESLint file created which to apply rules which target both the front and backend.

### Frontend/Client

The frontend is bootstrapped with [Vite](https://vitejs.dev/guide/) using the React/Typescript template.

- [React](https://reactjs.org/docs/getting-started.html), front-end library for creating user interfaces
- [Cypress](https://docs.cypress.io/guides/overview/why-cypress), testing library for creating intergration and unit test
- [Apollo Client](https://www.apollographql.com/docs/react/) state management tool for making queries/mutations to a GraphQL server and managing the state of those requests.
- [Formik](https://formik.org/), front-end library for creating and managing forms in React
- [Styled Components](https://styled-components.com/) front-end library for writing CSS in React components
- [React Router](https://reactrouter.com/en/main) front-end library creating page navigation for a React application

Other packages installed include [yup](https://www.npmjs.com/package/yup) and [validator](https://www.npmjs.com/package/validator) to assist Formik with form validation for the login and sign up pages.

### Backend/Server

- [Apollo Server](https://www.apollographql.com/docs/apollo-server), GraphQL server for creating queries and mutations
- [MongoDB](https://www.mongodb.com/), database for storing user information and bookmarked content
- [Mongoose](https://mongoosejs.com/docs/), ODM for MongoDB
- [supertest](https://www.npmjs.com/package/supertest), testing library for testing the GraphQL server

Authentication is handled with [JSON Web tokens](https://www.npmjs.com/package/jsonwebtoken), with [bcrypt](https://www.npmjs.com/package/bcrypt) used to hash passwords.

I chose GraphQL as the server because it was easier to structure and grab data from a query or mutation. Since I was using TypeScript, the [graphql codegen tool](https://the-guild.dev/graphql/codegen) allowed me to insert all my GraphQL schema's into one file, run the codegen command, and generate the type information for queries and mutations. MongoDB was chosen because it is the database program that I am most familiar with, along with using Mongoose to create the schemas.

### Docker

- [Docker Desktop](https://www.docker.com/products/docker-desktop/)
- [Docker Compose](https://docs.docker.com/compose/)

Before starting this project, I had just learned about Docker basics and its benefits to frontend/backend development. Two Docker Compose files were created that initalize a database in a virtual environment that can be accessed by the application. One for the developer environment, the other for the test environment(does not initialize data on build, and allows for the use of a reset query for the entire database). A JavaScript file in the root directory was created which is used by docker to intialize the database in the docker container.

`docker-compose-test.yml` was created to create and run a test database and server for the application. The `docker-compose.production.yml` file was created to create and run a production database and server for the application, which is used to test production locally.

## Development

This section will cover the development progress as I created the application, along with the issues I encountered and my solutions to them.

### Frontend

I have experience building one-page applications, but have never built an applicaiton that needed page routing. With the use of the _react-router_ library and its documentation, I was able to get a functioning routing system for the application. Since I was also using _apollo-client_ to handle the query and mutation state, I dont believe I using the full capabilities of react-router. In the future I want to return to the application and use react-router and apollo-client in more efficient ways.

#### Searching for Content

How content is searched can depend on the page the user is on. On the Movies/Shows/Bookmark page, when a user searches for content the server is not being called, rather the cached data from the initial query hook is used.

{/* Codeblock image needed here */}

In the `Movie.tsx` component, a memoized value of searched content is created when the user changes the value of the search text, if there is search text, we pass that data to the SearchResults.tsx component to display the filtered data.

{/* home component image needed here */}

In the code block above, a "lazy" query is created which only fires if the returned function is called, in this case **getSearch**. If the state of "search" has a value, and the hook is no longer loading, then we display the results of that hook to the user. On the surface it works the same as as the other pages, but it is constantly making network request to the server on each keystroke, I plan to implement a "debounced" or "throttled" solution in the future to decrease amount of times a network call is made.

#### React Router

To create seamless page navigation, verion six of the the _react-router_ library was implemented. If any error occurs users will receive an error page and be navigated back to the login page. _React.Suspense_ was implemented to lazy load pages that are not required by the application when initally rendered. For example, the `Movies.tsx` will not be imported on initial page load, but when a user navigates to "/movies", then they are shown a loading component until the `Movies.tsx` component is imported.

{/* Codeblock image needed here for react router config */}

#### Login & Sign Up

Users can navigate to the login page and sign up page, and once verified, the user is directed to the homepage. A JSON WebToken is created and saved in [local storage](https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage), which is inserted into every query to the GraphQL server for continous authentication.

When a user leaves the applicaiton and returns, if the token in the local storage is still valid, they are navigated direclty to the homepage, else the application navigates back to the login page. The **Dashboard** route calls a GraphQL query to verify the token. See the code block below:

{/* Codeblock image needed here for dashboard route */}

_Formik_ is used to manage form state, however, in the future I want to switch over to [react-hook-form](https://react-hook-form.com/) since I find building forms with that library works better than Formik.

#### Apollo Client

The _Apollo Client_ library is used to handle state management for GraphQL queries and mutations. Similar to the server, the _codegen_ library is used to read a GraphQL schema file and generate the necesssary types and hooks based on the schema. In the code block below, a generated hook is used to retrieve all movie content from the server:

{/* Codeblock image needed here for getMovies */}

The codeblock below demonstrates a generatead mutation hook being used to bookmark content:

{/* Codeblock image needed here for bookmarkMovie */}

### Backend

This was my first time creating my own backend service, however, thanks to [Fullstack TypeScript](https://frontendmasters.com/courses/fullstack-typescript/) course provided by [FrontEndMasters](https://frontendmasters.com/), I was able to find a good starting point to begin development. I had knowledge of both TypeScript and GraphQL, but didnt't have any experience putting it all togther. This course really helped me start this project and help make it what it is today, and I would highly recommend the FrontEndMasters service.

#### Server Constants

{/* image of server configuration constants file */}
For production and development purposes, a file containing various constant variables was created to be accessed throught the application which provides the following information:

- Path for client directory
- Path to static folder
- Path to the GraphQL Schema
- Port for the GraphQL server
- The MongoDB URL to use from the `.env` file.

#### Creating the server

{/* IMage of the create apollo server function in index.ts */}

The GraphQL server is created along with express, and acts as as a middlware for the application. The GraphQL Schema file is located in the root directory and contains query and mutation information for the server. The path to the schema is provided to the apollo server thanks to the constant variable created in the `constants.ts` file, as seen above. A file named [`resolvers.ts`] contains an object with the resolver information which is imported into this file and injected into the apollo server arguments using the `addResolversToSchema` method.

The apollo server creates a context which extracts a possible JWT token, decodes the token, and returns the decoded data as `currentUser` in every resolver. It checks for a authorization header, and if there is a valid head, it attempts to decode a token, else it skips this step. If it doesnt find a token then `currentUser` is set to null and the GraphQL query or mutation will throw an error as seen below:

{/* image of movies resolver with threw new auth */}

The only plugin provided to the server configuration is the [`ApolloServerPluginDrainHttpServer`](https://www.apollographql.com/docs/apollo-server/api/plugin/drain-http-server/) plugin, which ensures the server shuts down gracefully. At the end of the function we start the server, apply the express app as a middleware, and return the instance of the server. The Apollo server is attached to the Express server.

#### Initializing the server

{/* image of the database initialization file */}
The `main` function intializes the server by executing the following:

1. create a path to the static folder which will contain images used by the application.
2. Use the `createApolloServer` function with an HTTP server passsed in along with the express application created above the main function.
3. Grab the Mongo URL and Node environment from the `constants.ts` file.
4. Connect to the MongoDB database, if it fails we log an error, else we check to see if we are in the test environment. If in the test environment the database is not seeded, else the database is seeded.
5. Have the app listen to the PORT provied by `constants.ts` file.

#### MongoDB

{/* image of MongoDB user schema */}

A MongoDB database is used in this application, with a piece of content being defined as a movie or show, each having its own schema. The example above displays the mongoose schema for a user, it contains a relationship between users and shows/movies which keeps track of which movies/shows a user has bookmarked.

The movie and show schemas contain the title, rating, links to images, etc. Typescript along with mongoose is used to properly type the schemas. A typescript file named [`db.ts`](./server/src/database/db.ts) contains the schema types which are applied to the mongoose schemas and other parts of the application.

Models were created to interact with the database instead of having the queries/mutations interact with the database directly.

{/* Image of movie model */}

In the code block above the `getAllMovies` function uses the schema method `find` to grab all movies from the database. The `insertMovie` function creates a new movie object using the `NewMovie` type, and saves it to the database. The `deleteMovieById` function grabs a movie by its id, and deletes it from the database.

#### GraphQL resolvers

Multiple queries and mutations were created to interact with the graphQL server.

##### Query

{/* image of query resolver of grabbing movies */}

The code block above displays a `movies` resolver which checks to see if a logged in is making this query, if not then the resolver throws back an error that is handled by the client. If a user is logged then the following occurs:

1. Get the user information,
2. Grab the id's of all movies the user has bookmarked.
3. Grab all movie data, and for each movie check to see if that movie is bookmarked by the user by using `includes` Array method on the bookmarked movie array. Depending on this result, each movie instnace will have the property _bookmarked_ be marked as `true` or `false`.
4. A transform function is used to turn the `DBMovie` type into the proper type defined by the GraphQL schema. This just means removing MongoDB specific properties and methods.

##### Mutation

{/* image of mutation resolver of bookmarking a movie */}

The code block above displays the code of the mutation `bookmarkContent` which marks a movie/show as bookmarked under the target user in the schema. If an unauthenticated user is attempting to fire this mutation, then an error is thrown, else the mutation executes the following:

- If the target content is marked as a content type _show_, then:
  - Call the user service which inserts the show into the user's bookmarked show property
  - This function will throw an error if a show that is already bookmarked is being inserted again.

If the content being bookmarked is a movie, then the steps for bookmarking a show are repeated, but for the bookmarked movie property under the target user.

### Testing

This part was one of the most challenging aspects of this project since I had never tested a server before. I wanted to test the backend while it was running to ensure that all queries/mutations were called propertly with the correct arguments and proper results.

#### Frontend Testing

```typescript
describe('user login', () => {
  beforeEach(() => {
    cy.visit('/login');
    cy.request({
      method: 'POST',
      url: 'http://localhost:4000/graphql',
      body: {
        operationName: 'Mutation',
        query: 'mutation Mutation {resetDb}',
      },
    });
    cy.get('[data-cy="loginForm"]').as('loginForm');
    cy.get('[data-cy="loginEmail"]').as('loginEmail');
    cy.get('[data-cy="loginPassword"]').as('loginPassword');
    cy.get('[data-cy="loginButton"]').as('loginButton');
    cy.get('[data-cy="signUpLink"]').as('signUpLink');
  });

  it('valid login, redirected to home page', () => {
    cy.get('@loginEmail').type('testuser@gmail.com');
    cy.get('@loginPassword').type('Chopper!?990');
    cy.get('@loginButton').click();

    cy.get('@loginForm').should('not.exist');
    cy.url().should('include', '/dashboard');
    cy.get('[data-cy="dashboard"]');
  });

  ...

});
```

Above is a test for the login page, the test visits the login page, and grabs all the elements needed to interact with the login form. Cypress then types in the email and password, clicks the login button, verifies that the login form no longer exists, and confirms that the user user is directed to the dashboard page.

Using the `beforeEach hook`, each test will make a query to the server to reset the database, this _resetDB_ query will only execute if the server is in testing mode.

#### Backend Testing

According to the [Apollo Server documentation](https://www.apollographql.com/docs/apollo-server/testing/testing/), it is possible to test the resolvers without sending an HTTP request, but I wanted to test resolvers and the HTTP request together.

This led me to use the _supertest_ package to make direct request to the apollo server with custom GraphQL queries and mutations.

{/* image of user login test */}

Above is a test that verifies a user login and confirms that a token is retrieved. With supertest, we can set a base URL to send a request to and must create a GraphQL query or mutation to pass in. This was a very tedious task since there was no syntax help when writing the GraphQL query in this format. With this method I was able to test all main functionalities of the application with no client interaction required.

## Conclusion

There is alot more to say about the developemnt process of this application, regarding the testing issues, refactoring multiple queries into one, etc. One thing I want to research more is the context of GraphQL, in the FrontEndMasters course the instructor placed some Database methods into the context itself, I didnt do that here since I didn't fully understand why it was being done, but if it is a technique that will improve the application then it will be implemented in the future.

As I learn more about accessiblity, I wish to improve that aspect of the application as well.

If you have any questions about the development process up to this point please feel free to email me at `jorgemendozaiidev@gmail.com`.
