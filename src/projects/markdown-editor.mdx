---
title: Markdown Editor
slug: markdown-editor
repoLink: 'https://github.com/JorgeAMendoza/in-browser-markdown-editor'
demoLink: 'https://in-browser-markdown-editor-three.vercel.app/'
video:
  {
    poster: '/project-images/markdown-app/poster.webp',
    webm: '/project-images/markdown-app/markdown.webm',
    mp4: '/project-images/markdown-app/markdown.mp4',
  }
tableOfContents:
  [
    { sectionID: 'Introduction' },
    { sectionID: 'Techstack Used' },
    {
      sectionID: 'Development',
      subSections:
        ['Rendering Markdown', 'Redux', 'Application Logic and Structure'],
    },
    { sectionID: 'Conclusion' },
  ]
tools:
  [
    'react',
    'typescript',
    'marked',
    'styled-components',
    'cypress',
    'redux',
    'redux-toolkit',
  ]
---

## Introduction

Project requirements and design provided thanks to [FrontEndMentors](https://www.frontendmentor.io/challenges/inbrowser-markdown-editor-r16TrrQX9).

Before jumping into frameworks, I wanted to take the time to understand the fundamentals of web development. So a year in, I was capable of building simple applications with HTML, CSS, and JavaScript. At that point I figured it was time to start learning React and developing applications with the framework. This led me to take on this FrontendMentor challenge which I figured would provide a good challenge for me newly learned React skills.

The requirement of the project is to create a single-page markdown editor application that is capable of the following:

- Preview markdown syntax as HTML while editing
- Save markdown documents for later editing
- Switch between saved markdown documents
- Delete and edit markdown documents

## Techstack Used

This Project was bootstrapped with [Vite](https://vitejs.dev/guide/) using the the React/Typescript template. The project is linted with [ESLint](https://eslint.org/docs/latest/user-guide/getting-started) using react, prettier, cypress, and the [jsx-a11y](https://github.com/jsx-eslint/eslint-plugin-jsx-a11y) plugins. The main techstack used include:

- [React](https://reactjs.org/docs/getting-started.html), a JavaScript library for building user interfaces
- [Cypress](https://docs.cypress.io/guides/overview/why-cypress), a JavaScript testing library for creating end-to-end and unit tests
- [Styled Components](https://styled-components.com/), a CSS-in-JS tool for styling React components
- [Redux](https://redux.js.org/) and [Redux toolkit](https://redux-toolkit.js.org/), a state management tool for JavaScript applications
- [marked](https://www.npmjs.com/package/marked), a low-level compiler for parsing markdown without caching or blocking for long periods of time

The [Local Storage Browser API](https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage) is used to save markdown documents to the user's browser

## Development

This section discusses the development process of the application, and the challenges that were faced.

### Rendering Markdown

The first task I wanted to complete was converting the user input string into markdown on the page. It would take an extenstive amount of time to create my own implementation, so it was decided early on in development to implement a library that would handle this.

After some research, I came upon the `marked` library which was easy to configure and provided fast results. It takes in a string, and returns valid markdown syntax back as valid HTML string.

One issue with the package is that it does not sanitize the output HTML, meaning that attackers can inject potentially harmful code/syntax into the application. To remedy this, the [DOMPurify](https://www.npmjs.com/package/dompurify) package was installed which sanitizes HTML string. The implementation of this library can be found in the Preview Markdown sub section.

### Redux

When I initally planned the application and got the markdown render working, I came to the realization that I was creating many instances of state, and more importantly, was passing this state as props down through multiple components. This method of passing props down through multiple components is known as [prop drilling](https://dev.to/codeofrelevancy/what-is-prop-drilling-in-react-3kol) Some examples of this include:

- The left side-bar having to take in documents to display and switch over to another document.
- The top-bar needing document information to save documents and delete documents

Each markdown document is set to include the following information

1. The markdown contnet
2. The document name
3. The document status
4. The _original_ name of the document

Too many props were being passed through, making the codebase hard to read and page renders inefficient.

After a bit of research, I came to the conclusion that a state management tool will be needed for this application. **Redux along with Redux Toolkit** was chosen to manage the state of the application. Redux is the state management system itself, while Redux Toolkit contians method to work with the store in a simply way. This would be my first time using a state management tool, so before starting, I took the time to read through the documentation to get familiar with it.

#### Implementing Redux

As I planned out the state management structure, I came to the following conclusion: **the redux slice will hold information about the current document that is on the page**. This means that the left side-bar and top-bar components will no longer need to take in props, and instead can extract the document information from a central location, the Redux store.

One requirement of the of the application was to make it clear to the user when an "event" occured, these events include:

- Deleting a document
- Saving a document
- Changing the document title
- Overwriting a document

If any of these events occured, a modal would appear giving the user the ability to confirm the action, or cancel and leave the document in its current state. Again, instead of passing down props into the modal, the component itself can get the updated information from the store.

The implemenetation of the Redux slice can be found in the `document-reducer.ts` file. The reducer slice contains the following actions:

- `setMarkdownInformation`, takes in an object containing the entire markdown document information and sets it in the store
- `setMarkdownContent`, when a user types into the markdown text area, the slice's _documentMarkdown_ property is updated.
- `setCurrentMarkdownTitle`, change the title in the redux store (local storage change done somewhere else)
- `setNullDocument`, a user can delete a document and potentially be left with no document to view, thus the store should have a "null" state to indicate there is no document on the page to edit.
- `show/hideModal`, multiple boolean values were created that, if true, will display a certian modal (deleting, saving, overwriting, etc.), giving users the option to cancel/confirm the action. The `show` method for the modal ensures that every modal display boolean value is set to false, except the one that is passed into the payload. The `hide` method will set the payload's target to false, hiding the modal.

#### Redux Dispatch Functions

Instead of calling the dispatch function in the components and passing down the payload information directly, functions that return another function that call the store's dispatch with the arguments provided were created. I did this because it was easier to understand what dispatch was doing based on the name of the function, and it made the components more readable.

Still within `document-reducer.ts`, lets review the simple function below:

```tsx
export const updateCurrentDocumentTitle = (title: string) => {
  return (dispatch: AppDispatch) => {
    dispatch(setCurrentMarkdownTitle(title));
  };
};
```

The function `updateCurrentDocumentTitle` takes in a string and returns a function that calls the reducer dispatch function, in this case it calls the `setCurrentMarkdownTitle` action. How dispatch is called in the app will be explained later, but with this implementation, we have a function with a clear intent on what it does, and is responsible for a single update to the store. It may not seem like much, but to me this makes it easier to understand the intent of actions and organize our code-base as well.

#### Initializing the Store

With the reducer created and actions ready, all that is left is to initialize the store in the application. In the `redux-hooks.ts` file, two important hooks were created that allow components to interact with the store:

- `useAppDispatch`, returns a type-friendly dispatch function to fire actions to the store.
- `useAppSelector`, a hook that extracts the store properties and returns it to the component component.

This implementation is the redux-toolkit recommended practice, `store.ts` contains the defined types of the store which are used for the hooks.

### Application Logic and Structure

This sub-section will delve into the logic of the actions created from the redux slice, along with their use within the application. Though I already explained their purpose, providing more context to their use will paint a clearer picture of what I was attempting.

#### Initializing The Page

When the page loads, the application should display a _welcome_ markdown document. This document is created by calling the dispatch function with the `initalizeWelcomeMarkdown` function which creates a document object with the welcome markdown content, and sets the title of the document. This function is called in the [`App.tsx`](https://github.com/JorgeAMendoza/in-browser-markdown-editor/blob/main/src/App.tsx#L38C2-L46) file, which is the main entry point of the application. See the code snippet from the component below:

```tsx
useEffect(() => {
  dispatch(initializeWelcomeMarkdown());
  if (
    window.matchMedia &&
    window.matchMedia('(prefers-color-scheme: dark)').matches
  ) {
    setTheme('dark');
  } else setTheme('light');
}, []);
```

The `useEffect` hook, only on the initial render of the component, calls the dispatch function with the `initializeWelcomeMarkdown` action. This loads our page with the existing `welcome.md` markdown and ensure that our page renders the correct theme.

#### Saving a Document

When a user saves a document, the application must ensure the following:

- The document title is valid
- The document title does not already exist

In the [`TopBar.tsx`](https://github.com/JorgeAMendoza/in-browser-markdown-editor/blob/main/src/components/TopBar/TopBar.tsx#L40-L110) component, the `saveDocument` function is responsible for _validating document titles, confirming that documents are new, and confirming if a document needs to be overwritten_. When the user clicks the save button, the `saveDocument` function executes the following:

1. A simple regex is used to ensure that the document title is valid, if not, the _displayModal_ helper function within the dispatch is called to display the error modal to the user.
2. If a document is marked as new and the title does not exist in the local storage, the application can safely save the document without any issues. However, if a document in the storage matches the title of the current document, then the application will display the _overwrite_ modal to the user.
3. If a document is not new and the title already exists and matches data in local storage, the the application overwrites what is in the local storage and updates both the timestamp and redux store.
4. The store contains properties which includes the current and original title of the document when it was initlialized. If the current title does not match the original title, that means the user has changed the document title. So the application deletes the instance of the document from local storage with the original document name and saves another instance of the document with the new title.

If there is nothing in local storage then the application can safely assume that there are no documents, and can save the document without any issues.

If the document needs to be overwritten, the function which executes this can be found in [`App.tsx`](https://github.com/JorgeAMendoza/in-browser-markdown-editor/blob/main/src/App.tsx#L77-L103). If the overwrite occurs with a new document, then the function will grab the current document title and markdown information, and update the local storage data with the new information and fire the dispatch to update the redux store. If not a new document, that means that the currnet document had its title changed, so the document with the original title is deleted from the local storage and the current document information is added to the local storage data.

#### Deleting a Document

The logic for deleting a document exists in `App.tsx`, but the function to display the modal to fire the action to delete the document lives in the [`TopBar.tsx`](https://github.com/JorgeAMendoza/in-browser-markdown-editor/blob/main/src/components/TopBar/TopBar.tsx#L162C14-L179) component.

In the `DocOption` component (a styled-component wrapper), when a user clicks the delete button, the dispatch function is called with the result of `displayModal` passed the 'delete' argument to display the _delete_ modal.

The user is shown the modal, and can cancel or confirm the action.

The `App.tsx` component contains the `confirmDelete`function which can be seen below:

```tsx
const confirmDelete = () => {
  if (!document) return;

  if (document.isNewDocument) {
    dispatch(deleteDocument());
    return;
  }

  const savedDocuments = localStorage.getItem('savedMarkdown');
  if (!savedDocuments) {
    dispatch(removeModal('delete'));
    dispatch(deleteDocument());
    setShowMenu(false);
    return;
  }
  const savedDocumentsObject = JSON.parse(savedDocuments) as SavedDocument;
  delete savedDocumentsObject[document.originalDocumentTitle];
  localStorage.setItem('savedMarkdown', JSON.stringify(savedDocumentsObject));

  dispatch(removeModal('delete'));
  dispatch(deleteDocument());
  window.dispatchEvent(new Event('storage'));
};
```

The function executes the following:

1. If there is no document present, return.
2. Retrieve all documents in local storage, and if there are no documents, then delete the document from the redux store.
3. If documents exists in local storage, delete the object with the title name, and set the local storage to a new object which no longer has the current document information.
4. Finally, the dispatch to remove the modal is called, the document is removed from the Redux store, and the `window` object fires a storage event which ensures the document list reflects this change (more on this later).

#### Creating a new Document

The `Menu.tsx` component contains the function to display the modal to create a new document, depending on if the current document is _new_ or not, a variant of this modal will be shown. `App.tsx` contains the function to clear the modal and set a new document in the Redux store. See the code snippet below:

```tsx
const newDocumentToggle = () => {
  if (!document) dispatch(setNewDocument());
  else if (document.isNewDocument) dispatch(displayModal('discardNew'));
  else dispatch(displayModal('discardSaved'));
};
```

When `MenuDocButton` is clicked, the `newDocumentToggle` function executes the following:

1. If there is no document open, call the dispatch function with the argument of `setNewDocument` which will set a new document in the redux store.
2. If there is a document, and the document is new, then call the dispatch function with the argument of `displayModal` which will display the _discard new_ modal to the user.
3. If there is a document, and the document is not new, then call the dispatch function with the argument of `displayModal` which will display the _discard saved_ modal to the user.

The only difference between the two modals is that one indicates to the user that any un-saved changes will be lost, and the other indicates that the new document will be discarded.

The `App.tsx` component contains the [`confirmDiscard`](https://github.com/JorgeAMendoza/in-browser-markdown-editor/blob/main/src/App.tsx#L72-L75) function, which sets the redux store to a new document, and sets a boolean to false to hide the menu.

#### Switching Documents

Each `DocumentListItem.tsx` component contains the function [`switchDocument`](https://github.com/JorgeAMendoza/in-browser-markdown-editor/blob/main/src/components/DocumentList/DocumentListItem/DocumentListItem.tsx#L24-L47) which when fired, will set the target document in the redux store. See the snippet below:

```tsx
const switchDocument = () => {
  const savedMarkdown = localStorage.getItem('savedMarkdown');
  if (!savedMarkdown) {
    return;
  }

  if (!document) {
    const savedMarkdownObject = JSON.parse(savedMarkdown) as SavedDocument;
    if (!savedMarkdownObject[documentTitle]) {
      return;
    }

    dispatch(
      changeDocument(
        documentTitle,
        savedMarkdownObject[documentTitle].documentMarkdown
      )
    );
    return;
  } else {
    dispatch(applyTargetDoc(documentTitle));
    dispatch(displayModal('switch'));
  }
};
```

The `switchDocument` function executes the following:

1. Grabs all documents in local storage
2. If no documents exists, return.
3. If there is no document in the redux store and the target document does exist in local storage, call the dispatch function with `changeDocument` which takes in the target document title and the markdown to render.
   - If a document currently exists in the store, the user will be notified that any unsaved changes will be lost on the switch by calling `DisplayModal` with the `switch` variant in the dispatch function.

`App.tsx` contains the [`confirmSwitch`](https://github.com/JorgeAMendoza/in-browser-markdown-editor/blob/main/src/App.tsx#L105-L127) function which confirms or discards the document switch.

In the [`DocumentList`](https://github.com/JorgeAMendoza/in-browser-markdown-editor/blob/main/src/components/DocumentList/DocumentList.tsx) component, the `useEffect` hook is used to extract document information from local storage, parse it into a format that can be used by the state, and save the document list to the store so it can be rendered in the menu. The `useEffect` hook also adds an event listener to the window object to listen for changes to local storage. If a change is detected, the `checkLocalStorage` function is called again to update the store with the new document list.

#### Editing Markdown.

The [`MarkdownTextArea.tsx`](https://github.com/JorgeAMendoza/in-browser-markdown-editor/blob/main/src/components/DocumentEdit/MarkdownTextArea/MarkdownTextArea.tsx) component contains the `textarea` where users can edit markdown and fires the dispatch function to update the Redux store with the new markdown.

One tricky part of editing the document was inserting a _tab_ character when the user presses the `tab` key. By default, when a user tabs in a text-area, the keyboard navigates to the next keyboard navigation item. To insert a tab character, a `keyDown` event was required. The snippet for the text insertion can be seen below:

```tsx
<textarea
  data-cy="markdownTextArea"
  value={documentState.document?.documentMarkdown || ''}
  onChange={(e) => dispatch(updateMarkdown(e.target.value))}
  onBlur={(e) => dispatch(updateMarkdown(e.target.value))}
  onKeyDown={(e) => {
    const textArea = e.target;
    if (!(textArea instanceof HTMLTextAreaElement)) return;
    if (e.key == 'Tab') {
      e.preventDefault();
      const start = textArea.selectionStart;
      const end = textArea.selectionEnd;

      textArea.value =
        textArea.value.substring(0, start) +
        '   ' +
        textArea.value.substring(end);

      textArea.selectionStart = textArea.selectionEnd = start + 3;
      dispatch(updateMarkdown(textArea.value));
    }
  }}
/>
```

Within the `textarea` component, the function passed into the `onKeyDown` attribute executes the following:

1. Extract the text area from the event target and ensure that it is an `HTMLTextAreaElement` (Typescript check).
2. If the key pressed is the tab key, prevent the default action of leaving the `textarea`.
3. Grab the start and end of the selection in the text area, then insert three spaces at the start position, and concat the rest of the string after the end position.
4. Set the selection start and end to the start position plus 3 (the length of the tab character) to position cursor in its new position.
5. Dispatch the `updateMarkdown` action with the new markdown string.

#### Preview Markdown

The [`PreviewTextArea.tsx`](https://github.com/JorgeAMendoza/in-browser-markdown-editor/blob/main/src/components/DocumentEdit/PreviewTextArea/PreviewTextArea.tsx) component extracts the document markdown from the Redux store and uses _marked_ to parse the markdown into a valid HTML string.

See the code snippet below:

```tsx
return (
  <PreviewTextAreaStyled data-fullpreview={fullPreview}>
    <div>
      <h1>preview</h1>
      <button onClick={adjustPreview} aria-label="toggle full screen preview">
        <img src={showPreviewIcon} alt="" />
      </button>
    </div>
    <PreviewText
      data-cy="previewTextArea"
      dangerouslySetInnerHTML={{
        __html: DOMPurify.sanitize(html, { USE_PROFILES: { html: true } }),
      }}
    ></PreviewText>
  </PreviewTextAreaStyled>
);
```

In the `PreviewTextArea.tsx` component, the markdown is extracted from the redux store and the following occurs:

1. Have _marked_ create the HTML representation of the markdown.
2. Pass the results of _marked_ into _DOMPurify_ for sanitation.
3. Inject the HTML string onto the page with `dangerouslySetInnerHTML`.

The `DOMPurify` library is used to sanitize the HTML string to prevent XSS attacks. Since each store change renders the component, the variable `html` will be constantly updated with the new markdown.

## Conclusion

Overall this was a fun project to work on. I felt that I was able to get a good grasp on Redux fundamentals, discover a new way to render markdown on a web page, and work on a project that was more complex than previous projects I had worked on.

Some things I look to improve include:

1. Streamlining the logic, I feel that I put too many important functions in `App.tsx`, more structure to my project directory could help with this.
2. Implement unit test that would have helped me catch some of the bugs I encountered in specific components.
3. Migrate from local storage to `IndexedDB` for offline storage, and eventually add support for authentication so users can save their documents to a database to be accessed anywhere.
