---
title: 'Fullstack Entertainment Application'
slug: 'fullstack-entertainment'
repoLink: 'https://github.com/JorgeAMendoza/entertainment-web-app'
demoLink: 'https://jorge-fullstack-ent.com/'
projectGif: '/project-images/ent-app/showcase.gif'
projectImage: '/project-images/ent-app/project-image.png'
tableOfContents:
  [
    { sectionID: 'Introduction' },
    {
      sectionID: 'Techstack Used',
      subSections: ['Frontend', 'Backend', 'Docker'],
    },
    {
      sectionID: 'Development',
      subSections: ['Frontend', 'Backend', 'Testing'],
    },
    { sectionID: 'Conclusion' },
  ]
tools:
  [
    'graph-ql',
    'react',
    'typescript',
    'mongodb',
    'node-js',
    'styled-components',
    'cypress',
    'react-router',
  ]
---

## Introduction

Project requirements and design provided thanks to [FrontEndMentors](https://www.frontendmentor.io/challenges/entertainment-web-app-J-UhgAW1X).

The requirement of the project is to create an entertainment app where a user can navigate through TV shows, movies, bookmarked, or all content. The project's initial requirement is to create a user interface with static data provided, but as an extra challenge, I created a full-stack application that aimed to achieve the following:

1. **Authentication**, user's are able to create an account and can only interact with the application if they are authenticated.
2. **Database modification**, user's are able to bookmark content, remove bookmarked content, and have those changes reflect on the user-interface and in the backend.
3. **Front/backend testing**, test the entire application to have confidence in client-side and server-side deployments.

## Techstack Used

This section contains information about the technology used for both the front-end and backend. [ESlint](https://eslint.org/) is used to lint the application, with one general ESLint file created which to apply rules which target both the front and backend.

### Frontend

The frontend is bootstrapped with [Vite](https://vitejs.dev/guide/) using the React/Typescript template.

- [React](https://reactjs.org/docs/getting-started.html), front-end library for creating user interfaces
- [Cypress](https://docs.cypress.io/guides/overview/why-cypress), testing library for creating intergration and unit test
- [Apollo Client](https://www.apollographql.com/docs/react/), state management tool for making queries/mutations to a GraphQL server and managing the state of those requests.
- [Formik](https://formik.org/), front-end library for creating and managing forms in React
- [Styled Components](https://styled-components.com/) front-end library for writing CSS in React components
- [React Router](https://reactrouter.com/en/main) front-end library creating page navigation for a React application

Other packages installed include [yup](https://www.npmjs.com/package/yup) and [validator](https://www.npmjs.com/package/validator) to assist Formik with form validation for the login and sign up pages.

### Backend

- [Apollo Server](https://www.apollographql.com/docs/apollo-server), GraphQL server for creating queries and mutations
- [MongoDB](https://www.mongodb.com/), database for storing user information and bookmarked content
- [Mongoose](https://mongoosejs.com/docs/), ODM for MongoDB
- [supertest](https://www.npmjs.com/package/supertest), testing library for testing the GraphQL server

Authentication is handled with [JSON Web tokens](https://www.npmjs.com/package/jsonwebtoken), with [bcrypt](https://www.npmjs.com/package/bcrypt) used to hash passwords.

I chose GraphQL as the server because it was easier to structure and grab data from a query or mutation. Since I was using TypeScript, the [graphql codegen tool](https://the-guild.dev/graphql/codegen) allowed me to insert all my GraphQL schema's into one file, run the codegen command, and generate the type information for queries and mutations. MongoDB was chosen because it is the database program that I am most familiar with, along with using Mongoose to create the schemas.

### Docker

- [Docker Desktop](https://www.docker.com/products/docker-desktop/)
- [Docker Compose](https://docs.docker.com/compose/)

Before starting this project, I had just learned about Docker basics and its benefits to frontend/backend development. Two Docker Compose files were created that initalize a database in a virtual environment that can be accessed by the application. One for the developer environment, the other for the test environment(does not initialize data on build, and allows for the use of a reset query for the entire database). A JavaScript file in the root directory was created which is used by docker to intialize the database in the docker container.

`docker-compose-test.yml` was created to create and run a test database and server for the application. The `docker-compose.production.yml` file was created to create and run a production database and server for the application, which is used to test production locally.

## Development

This section will cover the development progress as I created the application, along with the issues I encountered and my solutions to them.

### Frontend

I had experience building one-page applications before, but had never built an applicaiton needing to navigate to different routes. With the use of the _react-router_ library and its documentation, I was able to get a functioning routing system for the application. Since I was also using _apollo-client_, I dont believe I used the full capabilities of react-router, but in the future I want to return to the application and use react-router and apollo-client in a more efficient manner.

#### Searching For Content

How content is searched can depend on the page the user is on. On the Movies/Shows/Bookmark page, when a user searches for content, cached data will be served instead of making a call to the server (if there is no cached data then server is called).

In the [`Movie.tsx`](https://github.com/JorgeAMendoza/entertainment-web-app/blob/main/client/src/routes/Movies.tsx) component/page, a memoized value of searched content is created when the user changes the value of the search text, if there is search text, we pass that data to the [`SearchResults.tsx`](https://github.com/JorgeAMendoza/entertainment-web-app/blob/main/client/src/components/SearchResults/SearchResults.tsx) component to display the filtered data.

The homepage handles searching differently, due to the query structure on the GraphQL server, there is a query hook that returns content based on the title text a user has passed in.

In the [`Homepage.tsx`](https://github.com/JorgeAMendoza/entertainment-web-app/blob/main/client/src/routes/HomePage/Homepage.tsx), a "lazy" query is created which only fires if the returned function is called, in this case **getSearch**. If the state of "search" has a value, and the hook is no longer loading, then we display the results of that hook to the user. On the surface it works the same was as the other pages, but it is constantly making network request to the server on each keystroke, I plan to implement a "debounced" solution in the future to cut down on the amount of times a network call is made.

#### React Router

To allow seamless page navigation, verion six of the the _react-router_ library was implemented. If any error occurs users will receive an error page and be navigated back to the login page. _React.Suspense_ was implemented to lazy load pages that may not be selected. For example, the `Movies.tsx` will not be imported on initial page load, but when a user navigates to "movies", then they are shown a loading component until the page component is imported. The implementation of the router can be found in the [`main.tsx`](https://github.com/JorgeAMendoza/entertainment-web-app/blob/main/client/src/main.tsx) component.

#### Log in/Sign up

Users can navigate to the login page and sign up page, and once verified, the user is directed to the homepage. A JSON WebToken is created in saved in [local storage](https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage), which is inserted into every query to the backend for continous authentication.

When a user leaves the applicaiton and returns, if the token in the local storage is still valid, they are navigated direclty to the homepage, else the application navigates back to the login page. The **Dashboard** route calls a GraphQL query to verify the token, which is handled in the [`Dashboard.tsx`](https://github.com/JorgeAMendoza/entertainment-web-app/blob/main/client/src/routes/Dashboard/Dashboard.tsx) component.

_Formik_ is used to manage the form state, however, in the future I want to switch over to [react-hook-form](https://react-hook-form.com/) since I find building forms with that library works better than Formik.

#### GraphQL/Apollo Client

The _Apollo Client_ library is used to handle state management for GraphQL queries and mutations. Similar to the backend, the _codegen_ library is used to read a GraphQL schema file and generate the necesssary types and hooks based on the schema. The generated hooks can be found in the [`graphql.tsx`](https://github.com/JorgeAMendoza/entertainment-web-app/blob/main/client/src/generated/graphql.tsx) file, with examples of the hook used in the [`Movie.tsx`](https://github.com/JorgeAMendoza/entertainment-web-app/blob/main/client/src/routes/Movies.tsx) component and the [`SmallContent.tsx`](https://github.com/JorgeAMendoza/entertainment-web-app/blob/main/client/src/components/SmallContent/SmallContent.tsx#L38) component.

### Backend

This was my first time creating my own backend service, however, thanks to [Fullstack TypeScript](https://frontendmasters.com/courses/fullstack-typescript/) course provided by [FrontEndMasters](https://frontendmasters.com/), I was able to find a good starting point to begin the process. I had knowledge of both TypeScript and GraphQL, but didnt't have the experience putting it all togther. This course really helped me start this project and help make it what it is today.

#### Server Configuration/Constants

For production and development purposes, the file [`constants.ts`](https://github.com/JorgeAMendoza/entertainment-web-app/blob/main/server/src/utils/constants.ts) containing various constant variables was created that can be accessed throught the application that provide the following information:

- Path for client code
- Path to static folder
- Path to the GraphQL Schema
- Port for the GraphQL server
- The MongoDB URL to use.

#### Creating the server

In the file [`apollo-server.ts`](https://github.com/JorgeAMendoza/entertainment-web-app/blob/main/server/src/apollo/apollo-sever.ts), the GraphQL server is created along with express, and acts as as a middlware for the application. The GraphQL Schema file is located in the root directory and contains query and mutation information for the server. The path to the schema is provided to the apollo server thanks to the constant variable created in the `constants.ts` file. A file named `resolvers.ts` contains an object with the resolver information which is imported into this file and injected into the apollo server arguments using the `addResolversToSchema` method.

The apollo server creates a context which extracts a possible JWT token, decodes the token, and returns the decoded data as `currentUser` in every resolver. It checks for a authorization header, and if there is a valid head, it attempts to decode a token, else it skips this step. If it doesnt find a token then `currentUser` is null the GraphQL query or mutation will throw an error as seen below:

GraphQL resolvers and the handling of errors can be found in the [`resolvers`](https://github.com/JorgeAMendoza/entertainment-web-app/tree/main/server/src/apollo/resolvers) directory in the GitHub respository.

The only plugin provided is the [`ApolloServerPluginDrainHttpServer`](https://www.apollographql.com/docs/apollo-server/api/plugin/drain-http-server/) plugin, which ensures the server shuts down gracefully. At the end of the function, we start the server, apply the express app as a middleware, and return the server. The Apollo server is attached to the Express server.

#### Intializing the Server

The `main` function found in [`index.ts`](https://github.com/JorgeAMendoza/entertainment-web-app/blob/main/server/src/index.ts)function intializes the server by executing the following:

1. create a path to the static folder whcih will contain images used by the application.
2. Use the `createApolloServer` function with an HTTP server passsed in along with the express application created above the main function.
3. Grab the Mongo URL and Node environment from the `constants.ts` file.
4. Connect to the MongoDB database, if it fails we log an error, else we check to see if we are in the test environment. If in the test environment the database is not seeded, else the database is seeded.
5. Have the app listen to the PORT provied by `constants.ts` file.

If you are on a local machine, you can now go to `localhost:4000/graphql` to view the GraphQL playground and make queries/mutations to the server.

#### MongoDB

A MongoDB database is used in this application, with a piece of content being defined as a movie or show, each having its own schema. The file [`user.ts`](https://github.com/JorgeAMendoza/entertainment-web-app/blob/main/server/src/database/schemas/user.ts) displays the mongoose schema for a user, it contains a relationship between users and shows/movies which keeps track of which movies/shows a user has bookmarked.

The movie and show schemas contain the title, rating, links to images, etc. Typescript along with mongoose is used to properly type the schemas. The typescript file titled [`db.ts`](https://github.com/JorgeAMendoza/entertainment-web-app/blob/main/server/src/database/db.ts) contains the schema types which are applied to the schemas and other parts of the application.

Models were created to interact with the database instead of having the queries/mutations interact with the database directly.

The file [`movie-service.ts`](https://github.com/JorgeAMendoza/entertainment-web-app/blob/main/server/src/database/services/movie-service.ts) contains various functions that interface with the database. For example, the `getAllMovies` function uses the schema method `find` to grab all movies from the database. The `insertMovie` function creates a new movie object using the `NewMovie` type, and saves it to the database. The `deleteMovieById` function grabs a movie by its id, and deletes it from the database.

The directory [`services`](https://github.com/JorgeAMendoza/entertainment-web-app/tree/main/server/src/database/services) contains the services for the user, movie, and show schemas.

#### GraphQL Resolvers

Multiple queries and mutations were created to interact with the graphQL server.

##### Query

The file named [`Query.ts`](https://github.com/JorgeAMendoza/entertainment-web-app/blob/main/server/src/apollo/resolvers/Query.ts#L15-L27) contains a `movies` resolver which checks to see if a valid user (logged in) is making this query, if not then the resolver throws back an error that is handled by teh client. If a user is logged then the following occurs:

1. Get the user information,
2. Grab the id's of all movies the user has bookmarked.
3. Grab all movie data, and for each movie check to see if that movie is bookmarked by the user by using `includes` Array method on the bookmarked movie array. Depending on this result, either a movie marked as "bookmarked" or not will be returned.
4. A transform function is used to turn the `DBMovie` type into the proper type defined by the GraphQL schema. This just means removing MongoDB specific properties and methods.

##### Mutation

The [`Mutation.ts`](https://github.com/JorgeAMendoza/entertainment-web-app/blob/main/server/src/apollo/resolvers/Mutation.ts#L29-L41) file contains the method of the mutation `bookmarkContent` which marks a movie/show as bookmarked under the target user in the schema. If an unauthenticated user is attempting to fire this mutation then an error is thrown, else the mutation executes the following:

1. If the target content is marked as a content type _show_, then:
   - Call the user service which inserts the show into the user's bookmarked show property
   - This function will throw an error if a show that is already bookmarked is being inserted again.
2. If the content being bookmarked is a movie, then the steps for bookmarking a show are repeated, but for the bookmarked movie property under the target user.

### Testing

This process was one of the most challenging sections of this project since I had never tested a backend before. I wanted to test the backend while it was running to ensure that all queries/mutations were called propertly with the correct arguments.

#### Frontend Testing

The file titled [`login.cy.ts`](https://github.com/JorgeAMendoza/entertainment-web-app/blob/main/client/cypress/e2e/login.cy.ts) contains the test for the login page, the test visits the login page and grabs all the elements needed to interact with the login form. Cypress then types in the email and password, clicks the login button, and verifies that the login form no longer exists, and that the user is redirected to the dashboard page.

Using the `beforeEach hook`, each test will make a query to the server to reset the database, this _resetDB_ query will only execute if the server is in testing mode.

All Cypress end-to-end test can be found in the directory titled [cypress/e2e](https://github.com/JorgeAMendoza/entertainment-web-app/tree/main/client/cypress/e2e)

#### Backend Testing

According to the [Apollo Server documentation](https://www.apollographql.com/docs/apollo-server/testing/testing/), it is possible to test the resolvers without sending an HTTP request, but I wanted to test resolvers and the HTTP request together.

This led me to use the _supertest_ package to make direct request to the apollo server with custom GraphQL queries and mutations.

The file [`users.test.ts`](https://github.com/JorgeAMendoza/entertainment-web-app/blob/main/server/src/__tests__/users.test.ts#L10-L31) contains a test that verifies a user login and confirms that a token is retrieved. With supertest, we can set a base URL to send a request to and must create a GraphQL query or mutation to pass in. This was a very tedious task since there was no syntax help when writing the GraphQL query in this format. Though with this method, I was able to test all main functionalities of the application with no client interaction required.

The main goal was to write test that could be run seperate from the client.

All backend test can be found in the directory named [tests](https://github.com/JorgeAMendoza/entertainment-web-app/tree/main/server/src/__tests__).

## Conclusion

There is alot more to say about the developemnt process of this application, regarding the testing issues, refactoring multiple queries into one, etc. One thing I want to research more is the context of GraphQL, in the FrontEndMasters course the instructor placed some Database methods into the context itself, I didnt do that here since I didn't fully understand why it was being done, but if it is a technique that will improve the application then it will be implemented in the future.

As I learn more about accessiblity, I wish to improve that aspect of the application as well.
