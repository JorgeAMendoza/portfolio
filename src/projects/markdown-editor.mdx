---
title: Markdown Editor
slug: markdown-editor
repoLink: 'https://github.com/JorgeAMendoza/in-browser-markdown-editor'
demoLink: 'https://in-browser-markdown-editor-three.vercel.app/'
video:
  {
    poster: '/project-images/markdown-app/poster.webp',
    webm: '/project-images/markdown-app/markdown.webm',
    mp4: '/project-images/markdown-app/markdown.mp4',
  }
tableOfContents:
  [
    { sectionID: 'Introduction' },
    { sectionID: 'Techstack Used' },
    {
      sectionID: 'Development',
      subSections:
        ['Rendering Markdown', 'Redux', 'Application Logic and Structure'],
    },
    { sectionID: 'Conclusion' },
  ]
tools:
  [
    'react',
    'typescript',
    'marked',
    'styled-components',
    'cypress',
    'redux',
    'redux-toolkit',
  ]
---

## Introduction

Project requirements and design provided thanks to [FrontEndMentors](https://www.frontendmentor.io/challenges/inbrowser-markdown-editor-r16TrrQX9).

The requirement of the project is to create a single-page markdown editor application that is capable of the following:

- Preview markdown syntax as HTML while editing
- Save markdown documents for later editing
- Switch between saved markdown documents
- Delete and edit markdown documents

## Techstack Used

This Project was bootstrapped with [Vite](https://vitejs.dev/guide/) using the the React/Typescript template. The project is linted with [Eslint](https://eslint.org/docs/latest/user-guide/getting-started) using react, prettier, cypress, and the [jsx-a11y](https://github.com/jsx-eslint/eslint-plugin-jsx-a11y) rules.

- [React](https://reactjs.org/docs/getting-started.html), a JavaScript library for building user interfaces
- [Cypress](https://docs.cypress.io/guides/overview/why-cypress), a JavaScript testing library for creating end-to-end and unit tests
- [Styled Components](https://styled-components.com/), a CSS-in-JS tool for styling React components
- [Redux](https://redux.js.org/) and [Redux toolkit](https://redux-toolkit.js.org/), a state management tool for JavaScript applications
- [marked](https://www.npmjs.com/package/marked), a low-level compiler for parsing markdown without caching or blocking for long periods of time

The [Local Storage Browser API](https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage) is used to save markdown documents to the user's browser

## Development

This section discusses the development process of the application, and the challenges that were faced.

### Rendering Markdown

The first goal I wanted to complete was converting/parsing string and rendering it into markdown on the page. It would take an extenstive amount of time to create my own implementation, so it was decided early in development to implement a package that would handle this.

After researching, I came upon the _marked_ library which was easy to configure and provided fast results. It takes in a string, and returns valid markdown syntax back as HTML string.

One issue with the package is that it does not sanitize the output HTML, meaning that attackers can inject potentially harmful code/syntax into the application. To remedy this, the [DOMPurify](https://www.npmjs.com/package/dompurify) package was installed which sanitizes HTML string. The logic for rendering markdown is as follows:

1. Have _marked_ create the HTML representation of the markdown
2. Pass the results of _marked_ into _DOMPurify_ for sanitation
3. Inject the HTML string onto the page with `dangerouslySetInnerHTML`

### Redux

Each markdown document is set to include the following information:

1. The markdown content
2. The document name
3. New document status
4. The _original_ name of the document

#### Disorgnaized State

When I initally planned the application and got the markdown render working, I came to the realization that I was creating many instances of state, and more importantly, was passing this state as props down through multiple components (_prop-drilling_). Some examples of this include:

- The left side-bar having to take in documents to display and switch over to another document.
- The top-bar needing document information to save documents and delete documents

Too much information was being passed down to each of these components, making it harder to understand what was going on and to read the application code.

After a bit of research, I came to the conclusion that a state management tool will be needed for this application. **Redux along with Redux Toolkit** was chosen to manage the state of the application. The main reason for this was that I wanted to practice using Redux, and Redux Toolkit makes it easier to implement Redux into an application.

#### Implementing Redux

As I implemented Redux into the applicaiton, I came to this conclusion: **the redux slice will hold information about the current document that is on the page**. This means that the left side-bar and top-bar components will no longer need to take in props, and instead can extract the document information from the redux store using the safely typed `useAppSelector` hook.

Another aspect of the application was to make it clear to the user when a major change to the application was occuring, these events include:

- Deleting a document
- Saving a document
- Changing the document title
- Overwriting a document

If any of these events occured, a modal would appear giving the user the ability to confirm these actions, or cancel and leave the document in its current state.

The implemenetation of the Redux slice can be found in the [`document-reducer.ts`](https://github.com/JorgeAMendoza/in-browser-markdown-editor/blob/main/src/redux/document-reducer.ts) file. The reducer slice contains the following methods:

- **Load a document**, the dispatch function can take in a document object and use it set the store to this document's information, displaying it on the page
- **Update the markdown content**, when a user types into the markdown text area, the slice's **current markdown** property is updated.
- **change the document title**, change the title in the redux store (local storage change done somewhere else)
- **remove a document/set store to null**, a user can delete a document and potentially be left with no document to view, thus the store should have a "null" state to indicate there is no document on the page to edit.
- **Hide/show a message to the user**, multiple boolean values were created that, if active, will display a certian modal (deleting, saving, overwriting, etc.), giving them the option to cancel/confirm the action. The show method for the modal ensures that every modal display boolean value is set to false, except the one that is passed into the payload. The hide action will set the payload's target to false, hiding the modal.

#### Redux Dispatch Functions

Instead of calling the dispatch function in the components and passing down the payload information directly, functions that return another function that will call the store's dispatch with the arguments provided were created. I did this because it was easier to understand what dispatch was doing based on the name of the function, and it made the components more readable.

Example of this can be found in the `document-reducer.ts` file in the [`initializeWelcomeMarkdown`](https://github.com/JorgeAMendoza/in-browser-markdown-editor/blob/main/src/redux/document-reducer.ts#L130-L149) function. The function returns another function that takes in a correctly typed dispatch function, an object containing the markdown file information is created and passed into the dispatch function which calls the store's `setMarkdownInformation` action with the payload.

### Application Logic and Structure

With Redux now implemented, the next step was to use these actions together to create the application structure and logic flow.

#### Initializing The Page

When the page loads, the application should display a _welcome_ markdown document. This document is created by calling the dispatch function with the `initalizeWelcomeMarkdown` function which creates a document object with the welcome markdown content, and sets the title of the document. This function is called in the [`App.tsx`](https://github.com/JorgeAMendoza/in-browser-markdown-editor/blob/main/src/App.tsx#L38C2-L46) file, which is the main entry point of the application. This is done in a `useEffect` hook that is only called once, when the page loads. This hook also checks to user's theme preferences and sets the color theme accordingly.

The `App.tsx` component can be seen below:

#### Saving a Document

When a user saves a document, the application must ensure the following:

- The document title is valid
- The document title does not already exist

In the [`TopBar.tsx`](https://github.com/JorgeAMendoza/in-browser-markdown-editor/blob/main/src/components/TopBar/TopBar.tsx#L40-L110) component, the `saveDocument` function is responsible for the following: validating document titles, confirming that documents are new, and confirming if a document needs to be overwritten. Implementation of that function can be seen below:

1. Validating document titles, a regex is used to ensure that the document title is valid, if not, the `displayModal` helper function within the dispatch is called to display the error modal to the user.
2. Confirming if a document is new, if a document is marked as new and the title does not exist in the local storage, the application can safely save the document without any issues. However, if a document in the storage matches the title of the current document, then the application will display the _overwrite_ modal to the user.
3. Saving a document, if a document is not new and the title already exists and matches something in local storage the the application overwrites what is in the local storage, udpates the timestamp, and updates the redux store.
4. Replacing a document, the store contains document which has the current title and the original title of the document when it was loaded in. If the current title does not match the original title, that means the user has changed the document title. So the application deletes the instance of the document with the original document name and saves another instance of the document with the new title.

If there is nothing in local storage then the application can safely assume that there are no documents, and can save the document without any issues.

If the document needs to be overwritten, the function which executes this can be found in [`App.tsx`](https://github.com/JorgeAMendoza/in-browser-markdown-editor/blob/main/src/App.tsx#L77-L103):

If the overwrite occurs with a new document, then the function will grab the current document title and markdown information, and update the local storage data with the new information and fire the dispatch to update the redux store. If not a new document, that means that the currnet document had its title changed, so the document with the original title is deleted from the local storage and the current document information is added to the local storage data.

#### Deleting a Document

The logic for deleting a document exists in `App.tsx`, but the function to display the modal to fire the action to delete the document lives in the [`TopBar.tsx`(https://github.com/JorgeAMendoza/in-browser-markdown-editor/blob/main/src/components/TopBar/TopBar.tsx#L162C14-L179)] component.

In the `DocOption` component (a styled-component wrapper), when a user clicks the delete button, the dispatch function is called with the result of `displayModal` passed the 'delete' argument to display the _delete_ modal.

The user is shown the modal, and can cancel or confirm the action.

The `App.tsx` component contains the [`confirmDelete`](https://github.com/JorgeAMendoza/in-browser-markdown-editor/blob/main/src/App.tsx#L48-L75) function which executes the following:

1. If there is no document present, just return to avoid errors.
2. Grab all documents in local storage, and if there are no documents, then just delete the document from the redux store.
3. If documents exists in local storage, delete the object with the title name, and set local storage to a new object which no longer has the current document information.
4. Finally, the dispatch to remove the modal is fired, the document is removed from the Redux store, and the `window` object fires a storage event which ensures the document list reflects this change.

#### Creating a new Document

The `Menu.tsx` component contains the function to display the modal to create a new document, depending on if the current document is _new_ or not, a variant of this modal will be shown. `App.tsx` contains the function to clear the modal and set a new document in the Redux store.

`Menu.tsx` contains the [`newDocumentToggle`](https://github.com/JorgeAMendoza/in-browser-markdown-editor/blob/main/src/components/Menu/Menu.tsx#L18-L22) function that is fired when a user clicks the _new document_ button, the function executes the following:

1. If there is no document currently store, call the dispatch function with the argument of `setNewDocument` which will set a new document in the redux store.
2. If there is a document, and the document is new, then call the dispatch function with the argument of `displayModal` which will display the _discard new_ modal to the user.
3. If there is a document, and the document is not new, then call the dispatch function with the argument of `displayModal` which will display the _discard saved_ modal to the user.

The only difference between the two modals is that one indicates to the user that any un-saved changes will be lost, and the other indicates that the new document will be discarded.

The `App.tsx` component contains the [`confirmDiscard`](https://github.com/JorgeAMendoza/in-browser-markdown-editor/blob/main/src/App.tsx#L72-L75) function, which sets the redux store to a new document, and sets a boolean to false to hide the menu.

#### Switching Documents

Each `DocumentListItem.tsx` component contains the function [`switchDocument`](https://github.com/JorgeAMendoza/in-browser-markdown-editor/blob/main/src/components/DocumentList/DocumentListItem/DocumentListItem.tsx#L24-L47) which when fired, will set the target document in the redux store. The `DocumentList.tsx` component grabs all documents from local storage and maps over them to render each instance of `DocumentListItem.tsx`.

The `switchDocument` function executes the following:

1. Grabs all documents in local storage
2. If no documents exists, return to avoid errors.
3. If there is no document in the redux store and the target document does exist in local storage, call the dispatch function with `changeDocument` which takes in the target document title and the markdown to render.
   - If a document currently exists in the store, the user will be notified that any unsaved changes will be lost on the switch by calling `DisplayModal` with the `switch` variant in the dispatch function.

`App.tsx` contains the [`confirmSwitch`](https://github.com/JorgeAMendoza/in-browser-markdown-editor/blob/main/src/App.tsx#L105-L127) function which confirms or discards the document switch.

In the [`DocumentList`](https://github.com/JorgeAMendoza/in-browser-markdown-editor/blob/main/src/components/DocumentList/DocumentList.tsx) component, the `useEffect` hook is used to extract document information from local storage, parse it into a format that can be used by the state, and apply document list to the state. The `useEffect` hook also adds an event listener to the window object to listen for changes to local storage. If a change is detected, the `checkLocalStorage` function is called again to update the state with the new document list.

#### Editing Markdown.

The [`MarkdownTextArea.tsx`](https://github.com/JorgeAMendoza/in-browser-markdown-editor/blob/main/src/components/DocumentEdit/MarkdownTextArea/MarkdownTextArea.tsx) component contains the `textarea` where users can edit markdown and fires the dispatch function to update the Redux store with the new markdown.

One tricky part of editing the document was inserting a _tab_ character when the user presses the tab key. By default, when a user tabs in a text-area, the keyboard navigates to the next tab target. To insert a tab character, a [`keyDown`](https://github.com/JorgeAMendoza/in-browser-markdown-editor/blob/main/src/components/DocumentEdit/MarkdownTextArea/MarkdownTextArea.tsx#L28-L44) event was required which executed the following.

1. Extract the text area from the event target and ensure that it is an HTMLTextAreaElement (Typescript check).
2. If the key pressed is the tab key, prevent the default action of leaving the `textarea`.
3. Grab the start and end of the selection in the text area, then insert three spaces at the start position, and concat the rest of the string after the end position.
4. Set the selection start and end to the start position plus 3 (the length of the tab character) to position cursor in its new position.
5. Dispatch the `updateMarkdown` action with the new markdown string.

#### Preview Markdown

The [`PreviewTextArea.tsx`](https://github.com/JorgeAMendoza/in-browser-markdown-editor/blob/main/src/components/DocumentEdit/PreviewTextArea/PreviewTextArea.tsx) component extracts the document markdown from the Redux store and uses _marked_ to parse the markdown into HTML. The prop `fullPreview` will display the preview area as full screen if true, else it will share the screen with the markdown editor component. The `dangerouslySetInnerHTML` prop is used to render the HTML string returned from the `marked` function. The `DOMPurify` library is used to sanitize the HTML string to prevent XSS attacks. Since each store change renders the component, the variable `html` will be constantly updated with the new markdown.

## Conclusion

Overall this was a fun project to work on. I felt that I was able to get a good grasp on Redux fundamentals, discover a new way to render markdown on a web page, and work on a project that was more complex than previous projects I have worked on.

Some things I look to improve include:

1. Simplying logic, I feel that I put too many important functions in `App.tsx`, using Redux should privide a better way to organize these fucntions.
2. Implement unit test that would have helped me solve some of the bugs I encountered in specific components.
3. Migrate from local storage to `IndexedDB` for offline storage, and eventually add support for authentication so users can save their documents to a database to be accessed anywhere.
